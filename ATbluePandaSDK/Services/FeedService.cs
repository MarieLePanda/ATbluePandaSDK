using ATPandaSDK.Models.Feed;
using ATPandaSDK.Models.PostCreation;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace ATPandaSDK.Services
{
    public class FeedService
    {
        private readonly HttpClient _httpClient;
        /// <summary>
        /// Initializes a new instance of the <see cref="FeedService"/> class.
        /// Sets up the HTTP client with the base address defined in the application's configuration and a logger.
        /// </summary>
        public FeedService()
        {
            _httpClient = new HttpClient { BaseAddress = new Uri(Configuration.BaseUrl) };
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FeedService"/> class.
        /// </summary>
        /// <param name="httpClient">An instance of <see cref="HttpClient"/> to use.</param>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="httpClient"/>is null.</exception>
        public FeedService(HttpClient httpClient)
        {
            _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient), "HttpClient cannot be null.");
        }

        /// <summary>
        /// Retrieves a custom feed generated by a feed generator, supporting pagination.
        /// </summary>
        /// <param name="accessToken">The authentication token required for the request.</param>
        /// <param name="feed">The identifier of the feed generator.</param>
        /// <param name="limit">The maximum number of posts to retrieve.</param>
        /// <param name="cursor">An optional cursor for pagination. If provided, fetches the next set of posts.</param>
        /// <returns>
        /// A <see cref="Task{TimelineResponse}"/> representing the asynchronous operation,  
        /// containing the feed data if successful, or an error message otherwise.
        /// </returns>
        /// <exception cref="ArgumentException">Thrown if <paramref name="accessToken"/> or <paramref name="feed"/> is null or empty.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if <paramref name="limit"/> is less than or equal to zero.</exception>
        public async Task<BskyTimeline> GetFeedGeneratorAsync(string accessToken, string feed, int limit, string cursor)
        {
            var url = $"{Configuration.GetFeed}?feed={Uri.EscapeDataString(feed)}&limit={limit}";

            if (!string.IsNullOrEmpty(cursor))
            {
                url += $"&cursor={Uri.EscapeDataString(cursor)}";
            }

            return await GetTimelineAsync(accessToken, url);
        }

        /// <summary>
        /// Retrieves the feed of a specific author, allowing pagination with a cursor.
        /// </summary>
        /// <param name="accessToken">The authentication token required for the request.</param>
        /// <param name="actorDid">The decentralized identifier (DID) of the author whose feed is being requested.</param>
        /// <param name="limit">The maximum number of posts to retrieve.</param>
        /// <param name="cursor">An optional cursor for pagination. If provided, fetches the next set of posts.</param>
        /// <returns>
        /// A <see cref="Task{TimelineResponse}"/> representing the asynchronous operation,  
        /// containing the author's feed data if successful, or an error message otherwise.
        /// </returns>
        /// <exception cref="ArgumentException">Thrown if <paramref name="accessToken"/> or <paramref name="actorDid"/> is null or empty.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if <paramref name="limit"/> is less than or equal to zero.</exception>
        public async Task<BskyTimeline> GetAuthorFeedAsync(string accessToken, string actorDid, int limit, string cursor)
        {
            var url = $"{Configuration.GetAuthorFeed}?actor={Uri.EscapeDataString(actorDid)}&limit={limit}";

            if (!string.IsNullOrEmpty(cursor))
            {
                url += $"&cursor={Uri.EscapeDataString(cursor)}";
            }

            return await GetTimelineAsync(accessToken, url);
        }

        /// <summary>
        /// Retrieves a paginated timeline with a specified limit and an optional cursor for pagination.
        /// </summary>
        /// <param name="accessToken">The authentication token required for the request.</param>
        /// <param name="limit">The maximum number of posts to retrieve.</param>
        /// <param name="cursor">An optional cursor for pagination. If provided, it fetches the next set of posts.</param>
        /// <returns>
        /// A <see cref="Task{TimelineResponse}"/> representing the asynchronous operation,  
        /// containing the timeline data if successful, or an error message otherwise.
        /// </returns>
        /// <exception cref="HttpRequestException">Thrown if an HTTP error occurs during the request.</exception>
        public async Task<BskyTimeline> GetTimelineAsync(string accessToken, int limit, string cursor)
        {
            var url = $"{Configuration.GetTimeline}?limit={limit}";
            if (!string.IsNullOrEmpty(cursor))
            {
                url += $"&cursor={cursor}";
            }

            return await GetTimelineAsync(accessToken, url);
        }

        /// <summary>
        /// Fetches the timeline from the specified URL.
        /// </summary>
        /// <param name="accessToken">The authentication token required for the request.</param>
        /// <param name="url">The API endpoint URL to retrieve the timeline.</param>
        /// <returns>
        /// A <see cref="Task{TimelineResponse}"/> representing the asynchronous operation,  
        /// containing the timeline data if the request succeeds, or an error message otherwise.
        /// </returns>
        /// <exception cref="HttpRequestException">Thrown if an HTTP error occurs.</exception
        private async Task<BskyTimeline> GetTimelineAsync(string accessToken, string url)
        {
            _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);

            HttpResponseMessage response = await _httpClient.GetAsync(url);
            
            if (response.IsSuccessStatusCode)
            {
                string jsonResult = await response.Content.ReadAsStringAsync();
                BskyTimeline timelineResponse = JsonSerializer.Deserialize<BskyTimeline>(jsonResult);
                return timelineResponse;
            }
            else
            {
                string errorResponse = await response.Content.ReadAsStringAsync();
                return new BskyTimeline
                {
                    ErrorMessage = errorResponse
                };
            }
        }
    }
}
